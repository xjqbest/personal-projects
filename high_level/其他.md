
### 高并发

QPS越高系统能hold住的请求数越多。TP90/TP99指标，这个指标不是求平均，而是把时延从小到大排序，取排名90%/99%的时延，这个指标越大，对慢请求越敏感。

思路：横向扩展（分布式）、纵向扩展（单机）

 - `负载均衡`：把负载均衡分配到不同的服务实例，利用集群的能力去对抗高并发。
 - `缓存`：针对写少读多的场景，很适合引入缓存集群。缓存穿透（查询不存在的数据）通过布隆过滤器解决，缓存雪崩（大量缓存在一个时刻同时失效）通过为缓存失效时间添加随机值。
 - `消息队列`：高写入的场景，削峰。
 - `流控`
 - `池化`：资源的“预分配”和“循环使用”。比如线程池、对象池、连接池等。
 - `流量漏斗`：比如从客户端请求到接入层，到逻辑层，到DB层，层层递减，过滤掉请求。


### 高可用

 - 主备切换，缩减故障时间：如果主节点不可用，自动切换到备用节点。
 - 熔断，提供过载保护：负载超过系统的承载能力时，系统会自动采取保护措施，确保自身不被压垮。
 - 限流，提供过载保护：只处理自己能力范围之内的请求，超量的请求会被限流。
 - 降级：业务在峰值时刻，系统抵挡不住全部的流量时，系统的负载、CPU 的使用率都超过了预警水位，可以对一些非核心的功能进行降级 ，降低系统压力


### 系统优化

步骤：建立baseline - 分析监控 - 找到瓶颈 - 优化与对比


### IO多路复用

<img width="689" alt="image" src="https://user-images.githubusercontent.com/12492564/153019961-f0f6899d-f03e-4d75-9f2c-238ba6550d67.png">

服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。

select：单个进程所打开的fd数量是有限制的。每次调用 select，都需要把 fd 集合从用户态拷贝到内核态。仅仅知道有I/O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流。

poll：它没有最大连接数的限制，原因是它是基于链表来存储的。其他跟select一样。

epoll：epoll会把哪个流发生了怎样的I/O事件通知我们，所以说epoll是事件驱动。并且epoll使用mmap减少复制开销。没有最大并发连接的限制。最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。
