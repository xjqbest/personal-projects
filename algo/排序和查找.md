## 二分查找

```cpp
int binary_search(int* arr, int l, int r, int x) {
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (arr[m] == x) {
            return m;
        }
        if (arr[m] < x) {
            l = m + 1;
        } else
            r = m - 1;
        }
    }
    return -1;
}
```

## 选择排序

```cpp
void selection_sort(int* arr, int n) { 
    for (int i = 0; i < n-1; i++) { 
        int min_idx = i; 
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[min_idx], &arr[i]); 
    } 
} 
```

## 插入排序

```cpp
void insertion_sort(int* arr, int n) { 
    for (int i = 1; i < n; i++) { 
        int key = arr[i]; 
        int j = i - 1; 
        while (j >= 0 && arr[j] > key) { 
            arr[j + 1] = arr[j]; 
            j = j - 1; 
        } 
        arr[j + 1] = key; 
    } 
} 
```

## 归并排序
分治法
```cpp
void merge_sort(int* array, int begin, int end) {
    if (begin >= end) return;
  
    auto mid = begin + (end - begin) / 2;
    merge_sort(array, begin, mid);
    merge_sort(array, mid + 1, end);
    // 需要额外的空间O(N）
    merge(array, begin, mid, end);
}
```

## 堆排序

```cpp
// 比如要对pair<int, int>排序
class SortHelper {
public:
    bool operator()(pair<int, int>& a, pair<int, int>& b) {
        if (a.first != b.first) {
            return a.first < b.first;
        } else {
            return a.second < b.second;
        }
    }
};

template<typename T, typename CMP>
class MinHeap {
public:
    Heap(T* x, int len, int capacity) {
        cmp_ = CMP();
        x_ = x;
        len_ = len;
        for (int i = len_ / 2 - 1; i >= 0; --i) {
          Build(i);
        }
    }
    void Build(int i) {
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int small = i;
        if (l < len_ && cmp_(x_[l], x_[i])) {
            small = l;
        }
        if (r < len_ && cmp_(x_[r], x_[samll])) {
            small = r;
        }
        if (small != i) {
            std::swap(x_[small], x_[i]);
            Build(small);
        }
    }
    T Pop() {
        T ans = x_[0];
        x_[0] = x_[len_ - 1];
        --len_;
        Build(0);
        return ans;
    }
    void Insert(T x) {
      if (len_ >= capacity) {
         std::cout << "no more insert" << std::endl;
      }
      x_[len_++] = T;
      int i = len_ - 1; 
      while (i >= 0 && x_[(i - 1) / 2] > x_[i]) {
         swap(&x_[i], &x_[(i - 1) / 2]);
         i = (i - 1) / 2;
      }
    }
protected:
  T* x_ = nullptr;
  int capacity_ = 0;
  int len_ = 0;
};
```

## 快排

```cpp
int partition (int* arr, int low, int high) { 
    int p = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++)  {
        if (arr[j] < p) { 
            i++;
            swap(&arr[i], &arr[j]); 
        } 
    } 
    swap(&arr[i + 1], &arr[high]); 
    return (i + 1); 
} 

void quick_sort(int* arr, int low, int high) { 
    if (low < high) {
        int p = partition(arr, low, high); 

        quickSort(arr, low, pi - 1); 
        quickSort(arr, pi + 1, high); 
    }
} 
```

## radix sort
```cpp
void count_sort(int* arr, int n, int exp) {
    int output[n];
    int count[10] = { 0 };
 
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }
 
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
 
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
 
    for (i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

void radix_sort(int* arr, int n) {
    int m = get_max(arr, n);

    for (int exp = 1; m / exp > 0; exp *= 10)
        count_sort(arr, n, exp);
}

```

## count sort
```cpp
void count_sort(int* arr, int n, int* output) {
    std::vector<int> count(RANGE + 1, 0);
    for (int i = 0; i < n; ++i) {
        ++count[arr[i]];
    }
    for (int i = 1; i <= RANGE; ++i)
        count[i] += count[i - 1];
    }
    for (int i = n - 1; i >= 0; --i)  { 
        output[count[arr[i]] - 1] = arr[i]; 
        --count[arr[i]]; 
    }
}
```

## bucket sort
应用场景：Sort a large set of floating point numbers which are in range from 0.0 to 1.0 and are uniformly distributed across the range. How do we sort the numbers efficiently?
时间复杂度：O(N)
```cpp
void buckets_ort(float* arr, int n) {
    // 1) Create n empty buckets
    vector<float> b[n];
 
    // 2) Put array elements in different buckets
    for (int i = 0; i < n; i++) {
        int bi = n * arr[i]; // Index in bucket
        b[bi].push_back(arr[i]);
    }
 
    // 3) Sort individual buckets
    for (int i = 0; i < n; i++)
        sort(b[i].begin(), b[i].end());
 
    // 4) Concatenate all buckets into arr[]
    int index = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < b[i].size(); j++)
            arr[index++] = b[i][j];
}
```
