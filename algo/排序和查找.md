## 二分查找

```cpp
int binary_search(int* arr, int l, int r, int x) {
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (arr[m] == x) {
            return m;
        }
        if (arr[m] < x) {
            l = m + 1;
        } else
            r = m - 1;
        }
    }
    return -1;
}
```

## 选择排序

```cpp
void selection_sort(int* arr, int n) { 
    for (int i = 0; i < n-1; i++) { 
        int min_idx = i; 
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[min_idx], &arr[i]); 
    } 
} 
```

## 插入排序

```cpp
void insertion_sort(int* arr, int n) { 
    for (int i = 1; i < n; i++) { 
        int key = arr[i]; 
        int j = i - 1; 
        while (j >= 0 && arr[j] > key) { 
            arr[j + 1] = arr[j]; 
            j = j - 1; 
        } 
        arr[j + 1] = key; 
    } 
} 
```

## 归并排序
分治法
```cpp
void merge_sort(int* array, int begin, int end) {
    if (begin >= end) return;
  
    auto mid = begin + (end - begin) / 2;
    merge_sort(array, begin, mid);
    merge_sort(array, mid + 1, end);
    // 需要额外的空间O(N）
    merge(array, begin, mid, end);
}
```

## 堆排序

```cpp
// 比如要对pair<int, int>排序
class SortHelper {
public:
    bool operator()(pair<int, int>& a, pair<int, int>& b) {
        if (a.first != b.first) {
            return a.first < b.first;
        } else {
            return a.second < b.second;
        }
    }
};

template<typename T, typename CMP>
class MinHeap {
public:
    Heap(T* x, int len, int capacity) {
        cmp_ = CMP();
        x_ = x;
        len_ = len;
        for (int i = len_ / 2 - 1; i >= 0; --i) {
          Build(i);
        }
    }
    void Build(int i) {
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int small = i;
        if (l < len_ && cmp_(x_[l], x_[i])) {
            small = l;
        }
        if (r < len_ && cmp_(x_[r], x_[samll])) {
            small = r;
        }
        if (small != i) {
            std::swap(x_[small], x_[i]);
            Build(small);
        }
    }
    T Pop() {
        T ans = x_[0];
        x_[0] = x_[len_ - 1];
        --len_;
        Build(0);
        return ans;
    }
    void Insert(T x) {
      if (len_ >= capacity) {
         std::cout << "no more insert" << std::endl;
      }
      x_[len_++] = T;
      int i = len_ - 1; 
      while (i >= 1 && x_[(i - 1) / 2] > x_[i]) {
         swap(&x_[i], &x_[(i - 1) / 2]);
         i = (i - 1) / 2;
      }
    }
protected:
  T* x_ = nullptr;
  int capacity_ = 0;
  int len_ = 0;
};
```

## 快排

```cpp
int partition (int* arr, int low, int high) { 
    int p = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++)  {
        if (arr[j] < p) { 
            i++;
            swap(&arr[i], &arr[j]); 
        } 
    } 
    swap(&arr[i + 1], &arr[high]); 
    return (i + 1); 
} 
// 递归版本
void quick_sort(int* arr, int low, int high) { 
    if (low < high) {
        int p = partition(arr, low, high); 

        quick_sort(arr, low, p - 1); 
        quick_sort(arr, p + 1, high); 
    }
} 
// 迭代版本
void quick_sort_iter(int* arr, int low, int high) {
    if(low >= high) {
        return;
    }
    
    std::vector<int> stack;
    int top = -1;
 
    stack[++top] = l;
    stack[++top] = h;

    while (top >= 0) {
        int h = stack[top--];
        int l = stack[top--];
 
        int p = partition(arr, l, h);
 
        if (p - 1 > l) {
            stack[++top] = l;
            stack[++top] = p - 1;
        }
 
        if (p + 1 < h) {
            stack[++top] = p + 1;
            stack[++top] = h;
        }
    }
}
```

## radix sort
```cpp
void count_sort(int* arr, int n, int exp) {
    int output[n];
    int count[10] = { 0 };
 
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }
 
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
 
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
 
    for (i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

void radix_sort(int* arr, int n) {
    int m = get_max(arr, n);

    for (int exp = 1; m / exp > 0; exp *= 10)
        count_sort(arr, n, exp);
}

```

## count sort
```cpp
void count_sort(int* arr, int n, int* output) {
    std::vector<int> count(RANGE + 1, 0);
    for (int i = 0; i < n; ++i) {
        ++count[arr[i]];
    }
    for (int i = 1; i <= RANGE; ++i)
        count[i] += count[i - 1];
    }
    for (int i = n - 1; i >= 0; --i)  { 
        output[count[arr[i]] - 1] = arr[i]; 
        --count[arr[i]]; 
    }
}
```

## bucket sort
应用场景：Sort a large set of floating point numbers which are in range from 0.0 to 1.0 and are uniformly distributed across the range. How do we sort the numbers efficiently?

时间复杂度：O(N)
```cpp
void buckets_ort(float* arr, int n) {
    // 1) Create n empty buckets
    vector<float> b[n];
 
    // 2) Put array elements in different buckets
    for (int i = 0; i < n; i++) {
        int bi = n * arr[i]; // Index in bucket
        b[bi].push_back(arr[i]);
    }
 
    // 3) Sort individual buckets
    for (int i = 0; i < n; i++)
        sort(b[i].begin(), b[i].end());
 
    // 4) Concatenate all buckets into arr[]
    int index = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < b[i].size(); j++)
            arr[index++] = b[i][j];
}
```



## 一些应用

### Sort a nearly sorted (or K sorted) array
Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time. For example, let us consider k is 2, an element at index 7 in the sorted array, can be at indexes 5, 6, 7, 8, 9 in the given array.

建一个大小为K的堆

### Find k closest elements to a given value
Given a sorted array arr[] and a value X, find the k closest elements to X in arr[]. Note that if the element is present in array, then it should not be in output, only the other closest elements are required.

首先二分查找找到最接近的两个点（l、r），然后往两边迭代（l--，r++）

### Search in an almost sorted array
Given an array which is sorted, but after sorting some elements are moved to either of the adjacent positions, i.e., arr[i] may be present at arr[i+1] or arr[i-1]. Write an efficient function to search an element in this array. Basically the element arr[i] can only be swapped with either arr[i+1] or arr[i-1].

二分查找
首先二分查找找到最接近的两个点（l、r），然后往两边迭代（l--，r++）

### Sort an array in wave form
Given an unsorted array of integers, sort the array into a wave like array. An array ‘arr[0..n-1]’ is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= …..

遍历偶数位置，使其大于旁边的两个数。

### K’th Smallest Element in Unsorted Array
Given an array and a number k where k is smaller than the size of the array, we need to find the k’th smallest element in the given array. It is given that all array elements are distinct.

（1）建一个最小堆，pop K次
（2）建一个最大堆，大小为K，再依次遍历后续元素，如果比堆顶大，跳过，如果比堆顶小，替换堆顶，并heapify
（3）借助快排的partition过程

### Find the closest pair from two sorted arrays
Given two sorted arrays and a number x, find the pair whose sum is closest to x and the pair has an element from each array. 
We are given two arrays ar1[0…m-1] and ar2[0..n-1] and a number x, we need to find the pair ar1[i] + ar2[j] such that absolute value of (ar1[i] + ar2[j] – x) is minimum.

两个指针：
```cpp
1) Initialize a variable diff as infinite (Diff is used to store the 
   difference between pair and x).  We need to find the minimum diff.
2) Initialize two index variables l and r in the given sorted array.
       (a) Initialize first to the leftmost index in ar1:  l = 0
       (b) Initialize second  the rightmost index in ar2:  r = n-1
3) Loop while  l = 0
       (a) If  abs(ar1[l] + ar2[r] - sum) < diff  then 
           update diff and result 
       (b) If (ar1[l] + ar2[r] <  sum )  then l++
       (c) Else r--    
4) Print the result. 
```

### Find common elements in three sorted arrays

三个指针，每次移动最小的

### Union and Intersection of two sorted arrays

两个指针，每次移动最小的

### Given a sorted array and a number x, find the pair in array whose sum is closest to x

两个指针（l、r），如果a[l] + a[r] < x, ++l, 否则--r。过程中维护最接近的。

