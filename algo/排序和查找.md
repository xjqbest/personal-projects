## 二分查找

```cpp
int binary_search(int* arr, int l, int r, int x) {
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (arr[m] == x) {
            return m;
        }
        if (arr[m] < x) {
            l = m + 1;
        } else
            r = m - 1;
        }
    }
    return -1;
}
```

## 选择排序

```cpp
void selection_sort(int* arr, int n) { 
    for (int i = 0; i < n-1; i++) { 
        int min_idx = i; 
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[min_idx], &arr[i]); 
    } 
} 
```

## 插入排序

```cpp
void insertion_sort(int* arr, int n) { 
    for (int i = 1; i < n; i++) { 
        int key = arr[i]; 
        int j = i - 1; 
        while (j >= 0 && arr[j] > key) { 
            arr[j + 1] = arr[j]; 
            j = j - 1; 
        } 
        arr[j + 1] = key; 
    } 
} 
```

## 归并排序
分治法
```cpp
void merge_sort(int* array, int begin, int end) {
    if (begin >= end) return;
  
    auto mid = begin + (end - begin) / 2;
    merge_sort(array, begin, mid);
    merge_sort(array, mid + 1, end);
    // 需要额外的空间O(N）
    merge(array, begin, mid, end);
}
```

## 堆排序

```cpp
// 比如要对pair<int, int>排序
class SortHelper {
public:
    bool operator()(pair<int, int>& a, pair<int, int>& b) {
        if (a.first != b.first) {
            return a.first < b.first;
        } else {
            return a.second < b.second;
        }
    }
};

template<typename T, typename CMP>
class MinHeap {
public:
    Heap(T* x, int len, int capacity) {
        cmp_ = CMP();
        x_ = x;
        len_ = len;
        for (int i = len_ / 2 - 1; i >= 0; --i) {
          Build(i);
        }
    }
    void Build(int i) {
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int small = i;
        if (l < len_ && cmp_(x_[l], x_[i])) {
            small = l;
        }
        if (r < len_ && cmp_(x_[r], x_[samll])) {
            small = r;
        }
        if (small != i) {
            std::swap(x_[small], x_[i]);
            Build(small);
        }
    }
    T Pop() {
        T ans = x_[0];
        x_[0] = x_[len_ - 1];
        --len_;
        Build(0);
        return ans;
    }
    void Insert(T x) {
      if (len_ >= capacity) {
         std::cout << "no more insert" << std::endl;
      }
      x_[len_++] = T;
      int i = len_ - 1; 
      while (i >= 0 && x_[(i - 1) / 2] > x_[i]) {
         swap(&x_[i], &x_[(i - 1) / 2]);
         i = (i - 1) / 2;
      }
    }
protected:
  T* x_ = nullptr;
  int capacity_ = 0;
  int len_ = 0;
```
